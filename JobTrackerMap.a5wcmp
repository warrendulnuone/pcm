{
    "$schema": "UX",
    "$definition": {
        "builderType": "CustomComponent",
        "subtype": "Google Map",
        "minimumBuildNumber": "",
        "guid": "7e10d120-79e2-46bf-b738-252469958ec6",
        "style_name": "Alpha",
        "componentName": "JobTrackerMap",
        "componentFilename": "C:\\pcm\\pcm.WebProjects\\Default.WebProject\\JobTrackerMap.a5wcmp",
        "style_type": "Alpha Five",
        "overrideStyleName": "Default",
        "resolveAbstractClassNames": true,
        "flagOKToPreviewBeforeUserEdits": true,
        "toolbarPosition": "Below",
        "DivName": "map_canvas",
        "CenterLat": 0,
        "CenterLng": 0,
        "markInitialPosition": true,
        "showMarkers": true,
        "showPolygon": true,
        "DivWidth": "400px",
        "DivHeight": "500px",
        "radius": 1609,
        "maxMarkers": 4,
        "reinitOnGeocode": true,
        "zoom": 13,
        "Titles": "",
        "InfoText": "",
        "showCircle": false,
        "isDraggable": true,
        "isInitialDraggable": false,
        "CenterAddress": "",
        "MapTypeId": "ROADMAP",
        "usePremier": false,
        "clientID": "",
        "useSSL": true,
        "useSensor": false,
        "apiKey": "",
        "initializeFromSensor": false,
        "markerPropertyArrayString": "",
        "autoScaleToBulkMarkers": true,
        "bulkMarkerClickAction": "null",
        "rightClickAction": "null",
        "CircleColor": "#00FF00",
        "PolygonColor": "#FF0000",
        "GeocodeDelay": 0,
        "GeocodeMethod": "Google",
        "setActiveRowOnMarkerClick": true,
        "clusterBulkMarkers": false,
        "GoogleMapsSrc": "https://maps.googleapis.com/maps/api/js?sensor=false&callback=A5.googleMapsInit.init",
        "HtmlToolbar": "<input class=\"{component.style}Input\" id=\"address\" type=\"textbox\" value=\"<enter address>\" />\n<input id=Geocode class=\"{component.style}Button\" type=\"button\" value=\"Geocode\" onclick=\"{Component.Object}.encodeAddressField()\" />\n<select id=radius onchange=\"{Component.Object}.setRadius(value)\" class=\"{component.style}Select\">\n\t<option value=\"1609\" default>1 mi</option>\n\t<option value=\"8047\">5 mi</option>\n\t<option value=\"16093\">10 mi</option>\n\t<option value=\"40234\">25 mi</option>\n\t<option value=\"80467\">50 mi</option>\n\t<option value=\"160934\">100 mi</option>\n</select>\n<input class=\"{component.style}Button\" id=Submit type=\"button\" value=\"Submit\" onclick=\"{Component.Object}.SubmitLatLng()\" />\n<!-- input type=\"button\" value=\"Markers\" onclick=\"{Component.Object}.toggleMarkers()\" -->\n<!-- input type=\"button\" value=\"Polygon\" onclick=\"{Component.Object}.togglePoly()\" -->\n<!-- button onclick=\"{Component.Object}.loadScript();\">Load JS</button -->\n",
        "XbasicFunctionDeclarations": "'Sample Callback function -- edit the action to your own purposes\nfunction TakeLatLng as C (e as P)\n\tdim npts as N = val(Request.Variables._npts)\n\tdim radius as C = Request.Variables._radius 'in meters\n\tdim LatLngArray[npts] as C 'e.g. [\"(42.478606, -71.201289)\",...]\n\tfor i=1 to npts\n\t\tLatLngArray[i] = eval(\"Request.Variables._LatLng\"+(i-1))\n\tnext\n\tdim showCircle as L = (\"true\" = Request.Variables._showCircle)\n\tdim showMarkers as L = (\"true\" = Request.Variables._showMarkers)\n\tdim showPolygon as L = (\"true\" = Request.Variables._showPolygon)\n\t'debug(1)\n\t'do something with the values\n\t'for example: pop up a message\n\tTakeLatLng = \"alert('radius is \" + radius + \" m around \"+LatLngArray[1]+\"');\"\n\t'for example: do a point-radius search if we're showing the circle, and display results\n\t'for example: do a Polygon search if we're showing the Polygons, and display results\nend function\n",
        "FontSize": "Medium",
        "serverSideEvents": {
            "onInitialRender": "",
            "onComponentInitialize": "",
            "onComponentExecute": "",
            "systemOnInitialRender": "function systemOnInitialRender as p (e as p)\n'This function is called to render the component.\n'First create the div for the map\n\n'debug(1)\n'e.tmpl.toolbarPosition\n\n'dim argsE as sql::arguments\n'dim toolbarPosition as c = \"Below\"\n'argsE.xml = e.arguments.xml\n'\n'dim argNum as n\n'argNum = e.arguments.ArgumentNumber(\"ToolbarPosition\")\n'if argNum > 0 then\n'\ttoolbarPosition = e.arguments[argNum].data\n'end if\n\ntoolbarPosition = e.tmpl.toolbarPosition\n\ne.html = <<%html%\n<div id=\"{DivName}\" style=\"height: {DivHeight}; width: {DivWidth}\">\n</div>\n%html%\n'Add the toolbar\nif toolbarPosition = \"Below\" then\n\te.html = e.html + <<%html%\n{HtmlToolbar}\n%html%\nelse\n\te.html = <<%html%\n{HtmlToolbar}\n%html% + e.html\n\n\n\nend if\n\n\n\ne.javascript = <<%js%\n{Component.Object}.markersArray = [];\n{Component.Object}.markersArray2 = [];\n{Component.Object}.infoWindowsArray = [];\n{Component.Object}.layersArray = [];\n{Component.Object}.circlesArray = [];\n{Component.Object}.geocoder; //only used for google geocoder\n{Component.Object}.map;\n{Component.Object}.marker;\n{Component.Object}.myPoly;\n{Component.Object}.showMarkers = {showMarkers};\n{Component.Object}.showPolygon = {showPolygon};\n{Component.Object}.markInitialPosition = {markInitialPosition};\n{Component.Object}.myRadius = \"{radius}\";\n{Component.Object}.maxMarkers = {maxMarkers};\n{Component.Object}.reinitOnGeocode = {reinitOnGeocode};\n{Component.Object}.titles = [\"{Titles}\"];\n{Component.Object}.InfoText = [\"{InfoText}\"];\n{Component.Object}.myCircle;\n{Component.Object}.showCircle = {showCircle};\n{Component.Object}.isDraggable = {isDraggable};\n{Component.Object}.isInitialDraggable = {isInitialDraggable};\n{Component.Object}.bulkMarkersArray = [{bulkMarkersArray}];\n{Component.Object}.bulkPolygonsArray = []; //mh 11/8/11 {bulkPolygonsArray}\n{Component.Object}.autoScaleToBulkMarkers = {autoScaleToBulkMarkers};\n{Component.Object}.bounds = null; //mh 11/14/11\n{Component.Object}.bulkMarkerClickAction = {bulkMarkerClickAction};\n{Component.Object}.clusterBulkMarkers = {clusterBulkMarkers}; //mh 11/8/11\n{Component.Object}.clusterer; //mh 11/14/11\n{Component.Object}.GeocodeDelay = {GeocodeDelay};\n{Component.Object}.GeocodeMethod = \"{GeocodeMethod}\";\n{Component.Object}.GoogleMapsSrc = \"{GoogleMapsSrc}\";\n{Component.Object}.useSensor = {useSensor};\n{Component.Object}.initializeFromSensor = {initializeFromSensor};\n{Component.Object}.maxLocationAge = 300000; //five minutes\n{Component.Object}.rightClickAction = {rightClickAction};\n{Component.Object}._onInitializeComplete = function(e) {\n\t{Component.Object}.loadScript();\n}\n{Component.Object}.parentGridAlias = \"{ParentGridAlias}\";\n{Component.Object}.setActiveRowOnMarkerClick = {SetActiveRowOnMarkerClick};\n\n//This function is called from the OnInitializeComplete client-side event\n//Dynamically load Google Maps API JavaScript, put it at the end of the page\n//It will run when the rest of the page has been processed, and\n// call back to initializeGoogleMap()\n{Component.Object}.loadScript = function(){\n\tif(typeof google == 'object') {\n\t\tif(typeof google.maps == 'object') {\n\t\t\t{Component.Object}.initializeGoogleMap() ;\n\t\t\treturn false;\n\t\t}\n\t}\n\tif(typeof A5.googleMapsInit == 'object') A5.googleMapsInit.maps.push('{Component.Object}');\n\telse{\n\t\tif({Component.Object}.clusterBulkMarkers) {\n\t\t\tA5.googleMapsInit = {\n\t\t\t\tinit: function() {\n\t\t\t\t\tvar sEle = document.createElement(\"script\");\n\t\t\t\t\tsEle.type = \"text/javascript\";\n\t\t\t\t\tsEle.src = \"markerclusterer.js\";\n\t\t\t\t\tdocument.body.appendChild(sEle);\n\t\t\t\t},\n\t\t\t\tinitComplete: function(){\n\t\t\t\t\tfor(var i=0;i<A5.googleMapsInit.maps.length;i++) eval(A5.googleMapsInit.maps[i]+'.initializeGoogleMap()');\n\t\t\t\t},\n\t\t\t\tmaps: ['{Component.Object}']\n\t\t\t}\n\t\t} else {\n\t\t\tA5.googleMapsInit = {\n\t\t\t\tinit: function(){\n\t\t\t\t\tfor(var i=0;i<A5.googleMapsInit.maps.length;i++) eval(A5.googleMapsInit.maps[i]+'.initializeGoogleMap()');\n\t\t\t\t},\n\t\t\t\tmaps: ['{Component.Object}']\n\t\t\t}\n\t\t}\n\n\t    var sEle = document.createElement(\"script\");\n\t    sEle.type = \"text/javascript\";\n\t    sEle.src = {Component.Object}.GoogleMapsSrc;\n\t    document.body.appendChild(sEle);\n    }\n} //end loadScript\n\n\n//callback from Google Maps startup\n//Geocode or otherwise set the initial map center,\n// then chain to initialize2\n\n{Component.Object}.initializeGoogleMap = function(){\n\t//initialize google.maps.Geocoder if we are going to use it\n\tif ({Component.Object}.GeocodeMethod == 'Google')\n\t\t{Component.Object}.geocoder = new google.maps.Geocoder();\n\n\t//load clusterer code if we are going to use it mh 11/14/11\n\n\n\t//Do we want to initialize from a sensor, and if so does the browser support HTML 5 geolocation?\n\tif({Component.Object}.useSensor && {Component.Object}.initializeFromSensor && navigator.geolocation) {\n\t\t//sensor takes priority over all other center initializations\n\t\tnavigator.geolocation.getCurrentPosition(\n\t\t  function(position) { //position callback\n  \t\t  \t  // Latitude and longitude available in position.coords\n  \t\t  \t  var myLatLng = new google.maps.LatLng(position.coords.latitude,position.coords.longitude);\n  \t\t  \t  {Component.Object}.initialize2(myLatLng);\n\t\t\t},\n\t\t  function(error) { //error callback\n\t\t  \t//alert('Could not determine position');\n\t\t    if(\"{CenterAddress}\".length>0) { //Geocode attempt takes precedence over center lat and lng\n\t\t\t\t{Component.Object}.encodeAddress('{CenterAddress}');\n\t\t\t\treturn; //avoid double call to initialize2\n\t\t\t}\n\t\t\tvar CenterLat = {CenterLat} || 42.478606;\n\t\t\tvar CenterLng = {CenterLng} || -71.201289;\n\t\t\tvar myLatLng = new google.maps.LatLng(CenterLat, CenterLng);\n\t\t\t{Component.Object}.initialize2(myLatLng);\n\t\t  \t},\n\t\t  {enableHighAccuracy: true, maximumAge: {Component.Object}.maxLocationAge} //position options\n\t\t); //end of getCurrentPosition\n\t\treturn; //avoid double call to initialize2\n\t} //end if\n\n    if(\"{CenterAddress}\".length>0) { //Geocode attempt takes precedence over center lat and lng\n\t\t{Component.Object}.encodeAddress('{CenterAddress}');\n\t\treturn; //avoid double call to initialize2\n\t}\n\t//No {CenterAddress}? Use Lat/Lng; default to Alpha main office\n\tvar CenterLat = {CenterLat} || 42.478606;\n\tvar CenterLng = {CenterLng} || -71.201289;\n\tvar myLatLng = new google.maps.LatLng(CenterLat, CenterLng);\n\t{Component.Object}.initialize2(myLatLng);\n} //end initialize\n\n//Try to Geocode the supplied address, then chain to initialize2\n{Component.Object}.encodeAddress = function(address) {\n    {Component.Object}.geoCodeCallback({\n        'address': address\n    }, function(location){ //Geocode callback function\n       \t{Component.Object}.initialize2(location);\n    });\n} //end encodeAddress\n\n//This function is chained from initialize or encodeAddress\n//Set map options, create map object, add map click listener,\n// mark initial position if wanted, and create bulk loaded markers\n{Component.Object}.initialize2 = function(myLatLng){\n    var myOptions = {\n        zoom: {zoom},\n        center: myLatLng,\n        mapTypeId: google.maps.MapTypeId.{MapTypeId}\n    }\n\n    var divId = $(\"{DivName}\");\n    //TODO: If the height of the div is given in %, compute pixels by multiplying by window.innerHeight\n\n    {Component.Object}.map = new google.maps.Map(divId, myOptions);\n\n    //This closure handles clicks on the map\n    google.maps.event.addListener({Component.Object}.map, 'click', function(event){\n        {Component.Object}.addMarker(event.latLng, {Component.Object}.isDraggable);\n    });\n\n    //This closure handles right-clicks on the map\n    google.maps.event.addListener({Component.Object}.map, 'rightclick', function(event){\n       \t//call rightClickAction function if defined\n\t\tif ({Component.Object}.rightClickAction && typeof {Component.Object}.rightClickAction == 'function') {\n\t\t\t{Component.Object}.rightClickAction(event.latLng);\n\t\t} else if ({Component.Object}.rightClickAction && typeof {Component.Object}.rightClickAction == 'string') {\n\t\t\tif(window[{Component.Object}.rightClickAction])\n\t\t\t\twindow[{Component.Object}.rightClickAction].call(this,event.latLng);\n\t\t}\n    });\n\n    if ({Component.Object}.markInitialPosition) {\n    \t{Component.Object}.addMarker(myLatLng, {Component.Object}.isInitialDraggable);\n    }\n\n\t//Process bulk marker array\n\t{Component.Object}.addBulkMarkersCallback({Component.Object}.bulkMarkersArray, false, false, {Component.Object}.autoScaleToBulkMarkers, false);\n\n\t//TODO: Watch position\n\n} //initialize2\n\n//addBulkMarkersCallback: add contents of markerArray argument to bulk markers\n//  API exposed for use by Ajax callbacks; called by initialize2\n{Component.Object}.addBulkMarkersCallback = function(markerArray, fClearAllMarkers, fClearBulkMarkers, fRecenterMapNew, fRecenterMapAll)\n{\n\n\tif (fClearAllMarkers) {\n\t\t{Component.Object}.deleteOverlays();\n\t} else if (fClearBulkMarkers) {\n\t\t{Component.Object}.deleteBulkMarkers();\n\t}\n\tif (fClearAllMarkers || fClearBulkMarkers || fRecenterMapNew) {\n\t\t{Component.Object}.bounds = null;\n\t}\n\tvar geoCount=0;\n\tif (markerArray.length>0) {\n\t\tfor (var i=0; i<markerArray.length; i++) {\n\t\t\tvar bma = markerArray[i];\n\t\t\tif(typeof bma.realRowNum == 'undefined') { \n\t\t\t\tbma.realRowNum = bma.rowNumber;\n\t\t\t}\n\t\t\t// address or coord?\n\t\t\tif (bma.type == 'address') {\n\t\t\t\tgeoCount++;\n\t\t\t\t{Component.Object}.doGeocode(bma.address, bma.title||'', bma.infotext||'', bma.icon||'',bma.realRowNum, bma.layer||'',\n\t\t\t\t\tbma.animation||0, bma.duration||0, bma.callback||null, bma.circleObj||{}, bma.isDraggable||false, bma.dragFunction||null);\n\t\t\t\t} //mh: changed \"i+1\" to bma.realRowNum in addBulkMarker calls above and below 6/25/2012\n\t\t\telse {\n\t\t\t\t//Make coord into LatLng and add\n\t\t\t\tvar ll = new google.maps.LatLng(bma.lat||0.0, bma.lon||0.0);\n\t\t\t\t{Component.Object}.addBulkMarker(ll, bma.title||'', bma.infotext||'', bma.icon||'',bma.realRowNum, bma.layer||'',\n\t\t\t\t\tbma.animation||0, bma.duration||0, bma.callback||null, bma.circleObj||{}, bma.isDraggable||false, bma.dragFunction||null);\n\t\t\t}\n\t\t}\n\n\t    if({Component.Object}.clusterBulkMarkers) { //mh 11/14/11\n\t    \tif ({Component.Object}.clusterer == null) {\n\t\t    \t{Component.Object}.clusterer = new MarkerClusterer({Component.Object}.map, {Component.Object}.markersArray2);\n\t\t    \t{Component.Object}.clusterer.fitMapToMarkers();\n\t\t   } else {\n\t\t   \t\t{Component.Object}.clusterer.clearMarkers();\n\t\t    \t{Component.Object}.clusterer.addMarkers({Component.Object}.markersArray2);\n\t\t    \t{Component.Object}.clusterer.fitMapToMarkers();\n\t\t    \t}\n\t   \t}\n\t\telse if(fRecenterMapNew || fRecenterMapAll) {\n\t\t\tsetTimeout(\"{Component.Object}.autoScaleMap();\",geoCount>0 ? {Component.Object}.GeocodeDelay : 1);\n\t\t}\n\t}\n}\n\n//doGeocode: address into LatLng, if we can\n// Note that geocoding is asynchronous\n{Component.Object}.doGeocode  = function(address, title, infotext, icon, rowNumber, layer, animation, duration, callback)\n{\n\tif(typeof address != 'string' || address == '') //mh 4/3/12\n\t\treturn;\n\n\t//handle the optional Circle object argument\n\tvar circleObj = typeof arguments[9] != 'undefined' ? arguments[9] : {};\n\n\t//handle the optional isDraggable and dragFunction arguments\n\tvar isDraggable = typeof arguments[10] == 'boolean' ? arguments[10] : false;\n\tvar dragFunction = typeof arguments[11] != 'undefined' ? arguments[11] : null;\n\n\t{Component.Object}.geoCodeCallback({\n\t\t'address': address\n\t}, function(location){ //Geocode callback function\n\t\t\t{Component.Object}.addBulkMarker(location, title, infotext, icon, rowNumber, layer, animation, duration, callback,\n\t\t\tcircleObj, isDraggable, dragFunction);\n\t});\n}\n\n{Component.Object}.doGeocode2  = function(address, canDrag)\n{\n\tif(typeof address != 'string' || address == '') //mh 4/3/12\n\t\treturn;\n\n\t{Component.Object}.geoCodeCallback({\n\t\t'address': address\n\t}, function(location){ //Geocode callback function\n\t\t{Component.Object}.addMarker(location, canDrag);\n\t});\n}\n\n//openInfoWindow\n{Component.Object}.openInfoWindow = function (index)\n{\n\tif ({Component.Object}.infoWindowsArray.length >= index)\n\t\t{Component.Object}.infoWindowsArray[index-1].open({Component.Object}.map,{Component.Object}.markersArray2[index-1]);\n}\n\n{Component.Object}.addBulkMarker2 = function (lat, lng, title, infotext, icon, rowNumber, layer, animation, duration, callback) {\n\t//handle the optional Circle object argument\n\tvar circleObj = typeof arguments[10] != 'undefined' ? arguments[10] : {};\n\t//handle the optional isDraggable and dragFunction arguments\n\tvar isDraggable = typeof arguments[11] == 'boolean' ? arguments[11] : false;\n\tvar dragFunction = typeof arguments[12] != 'undefined' ? arguments[12] : null;\n\n\tvar latlng = new google.maps.LatLng(lat, lng);\n\t{Component.Object}.addBulkMarker(latlng, title, infotext, icon, rowNumber, layer, animation, duration, callback,\n\t\tcircleObj, isDraggable, dragFunction);\n}\n\n//addBulkMarker: Add the LatLng marker, with infotext, title, icon, layer, animation, duration, callback,\n// ...and optionally a circle object, an isDraggable flag, and a function to call on dragend.\n// Also update bounds\n//rowNumber can be used by a defined bulkMarkerClickAction or dragFunction\n{Component.Object}.addBulkMarker = function (latlng, title, infotext, icon, rowNumber, layer, animation, duration, callback)\n{\n\t//handle the optional Circle object argument\n\tvar circleObj = typeof arguments[9] != 'undefined' ? arguments[9] : {};\n\t//handle the optional isDraggable and dragFunction arguments\n\tvar isDraggable = (typeof arguments[10] == 'boolean' ? arguments[10] : false) && !{Component.Object}.clusterBulkMarkers;\n\tvar dragFunction = typeof arguments[11] != 'undefined' ? arguments[11] : null;\n\tvar map = {Component.Object}.clusterBulkMarkers ? null : {Component.Object}.map;\n\tvar marker = new google.maps.Marker({\n\t\tposition: latlng,\n\t\tmap: map,\n\t\tdraggable: isDraggable,\n\t\ticon: icon,\n\t\tanimation: animation\n\t});\n\tmarker.setTitle(title);\n\tvar infowindow = new google.maps.InfoWindow(\n\t  { content: infotext||\"\"\n\t  });\n\t//keep track of infowindow for automated opening and closing\n\t{Component.Object}.infoWindowsArray.push(infowindow);\n\t//note: openInfoWindow() subtracts 1 from the passed index, for the convenience of the Grid code\n\tvar markerIndex = {Component.Object}.infoWindowsArray.length; //mh 11/28/11\n\n\t//This closure handles marker dragend\n\tif(isDraggable && typeof dragFunction != 'undefined' && dragFunction != null && !{Component.Object}.clusterBulkMarkers) {\n\t\tgoogle.maps.event.addListener(marker, 'dragend', function() {\n\t\t\t//call dragFunction if defined\n\t\t\tvar e = {\n\t\t\t\trowNumber: rowNumber\n\t\t\t}\n\t\t\tif (typeof dragFunction == 'function') {\n\t\t\t\tdragFunction(marker, e);\n\t\t\t} else if (typeof dragFunction == 'string') {\n\t\t\t\twindow[dragFunction].call(this, marker, e);\n\t\t\t}\n\t\t});\n\t}\n\n\t//This closure handles marker clicks\n\t//Can be open infowindow (default), or JavaScript passed to open detail view(rowNumber) or do a custom action(rowNumber)\n\tif(typeof {Component.Object}.bulkMarkerClickAction == 'undefined' || {Component.Object}.bulkMarkerClickAction == null)\n\t\tgoogle.maps.event.addListener(marker, 'click', Function([\n\t\t   'if({Component.Object}.setActiveRowOnMarkerClick) {',\n\t\t   '    if({Component.Object}.parentGridAlias != \\'\\') {',\n\t\t   '        window[{Component.Object}.parentGridAlias + \\'_GridObj\\'].setSelectedRow('+rowNumber+');',\n\t\t   '    }',\n\t\t   '}',\n\t\t   'for (var i = 0; i < {Component.Object}.infoWindowsArray.length; i++) {',\n\t\t   '    {Component.Object}.infoWindowsArray[i].close();',\n\t\t   '}',\n\t\t   '{Component.Object}.openInfoWindow('+markerIndex+');'].join('\\n')));\n\telse\n\t\tgoogle.maps.event.addListener(marker, 'click', function() {\n\t\t\teval({Component.Object}.bulkMarkerClickAction);\n\t\t});\n\n\t//keep track of markers for clearing and remote infobox activation\n\tmarker.rowNumber = rowNumber; //mh 11/28/11\n\t{Component.Object}.markersArray2.push(marker);\n\n\t//stop animation after duration (in seconds)\n\tvar i = {Component.Object}.markersArray2.length - 1;\n\tif (animation > 0 && duration > 0 && !{Component.Object}.clusterBulkMarkers)\n\t\tsetTimeout('{Component.Object}.markersArray2['+i+'].setAnimation(null);',1000*duration);\n\n\t//keep track of layer for this marker\n\t{Component.Object}.layersArray.push(layer);\n\n\t//Draw a circle if defined\n\tvar circle = null;\n\tif(circleObj.radius && !{Component.Object}.clusterBulkMarkers) {\n\t\tcircle = new google.maps.Circle({\n\t\t\tcenter: latlng,\n\t\t\tradius: circleObj.radius,\n\t\t\tmap: {Component.Object}.map,\n\t\t\tstrokeColor: circleObj.strokeColor||circleObj.fillColor||\"{CircleColor}\",\n\t        strokeOpacity: circleObj.strokeOpacity||0.8,\n\t        strokeWeight: circleObj.strokeWeight||2,\n\t        fillColor: circleObj.fillColor||circleObj.strokeColor||\"{CircleColor}\",\n\t        fillOpacity: circleObj.fillOpacity||0.35,\n\t        clickable: false\n\t\t});\n\t}\n\t{Component.Object}.circlesArray.push(circle);\n\n\t//compute bounds\n\tif ({Component.Object}.bounds == null)\n\t\t{Component.Object}.bounds = new google.maps.LatLngBounds();\n\t{Component.Object}.bounds.extend(latlng);\n\n\t//call callback function if defined\n\tif (callback && typeof callback == 'function') {\n\t\tcallback({Component.Object}.markersArray2[i]);\n\t} else if (callback && typeof callback == 'string') {\n\t\tif(window[callback]) window[callback].call(this,{Component.Object}.markersArray2[i]);\n\t}\n}\n\n//reset map bounds to fit all markers if wanted\n{Component.Object}.autoScaleMap = function() {\n\t{Component.Object}.map.fitBounds({Component.Object}.bounds);\n\t//handle the case of a single marker with automatic scaling\n\tif ({Component.Object}.map.getZoom() >= 20)\n\t\t{Component.Object}.map.setZoom({zoom});\n} //autoScaleMap\n\n{Component.Object}.addMarker2 = function(lat, lng, canDrag){\n\tvar latlng = new google.maps.LatLng(lat, lng);\n\t{Component.Object}.addMarker(latlng, canDrag);\n}\n\n//Add a marker to the map with a title and InfoText box\n//Add a listener for marker drag events\n//Show updated polygon if wanted\n//Show circle for the first marker if wanted\n{Component.Object}.addMarker = function(location, canDrag){\n\tvar num = {Component.Object}.markersArray.length;\n\tif(num >= {Component.Object}.maxMarkers) {\n\t\treturn;\n\t}\n\tvar whatMap = null;\n\tif({Component.Object}.showMarkers)\n\t\twhatMap = {Component.Object}.map;\n    {Component.Object}.marker = new google.maps.Marker({\n        position: location,\n        map: whatMap,\n        draggable: canDrag\n    });\n    {Component.Object}.markersArray.push({Component.Object}.marker);\n    try { {Component.Object}.marker.setTitle({Component.Object}.titles[num])}\n    catch (e) { }\n    {Component.Object}.attachInfoText({Component.Object}.marker, num);\n\n    //This closure handles marker dragging\n    google.maps.event.addListener({Component.Object}.marker, 'dragend', function(e) {\n   \t    if ({Component.Object}.showPolygon) {\n\t    \t{Component.Object}.clearPoly();\n\t        {Component.Object}.showPoly();\n\t\t}\n\t    if(num<2)\n\t    \t{Component.Object}.setRadius({Component.Object}.myRadius);\n  \t});\n\n  \t//This closure handle marker double-clicks\n     google.maps.event.addListener({Component.Object}.marker, 'dblclick', function(e) {\n\t    //debugger;\n     \tthis.setMap(null);\n      \t{Component.Object}.markersArray.splice(num,1);\n   \t    if ({Component.Object}.showPolygon) {\n\t    \t{Component.Object}.clearPoly();\n\t        {Component.Object}.showPoly();\n\t\t}\n\t    if(num<2)\n\t    \t{Component.Object}.setRadius({Component.Object}.myRadius);\n  \t});\n\n    if ({Component.Object}.showPolygon) {\n    \t{Component.Object}.clearPoly();\n        {Component.Object}.showPoly();\n    }\n    if(num<2)\n    \t{Component.Object}.setRadius({Component.Object}.myRadius);\n\n} //end addMarker\n\n//Attach an InfoText ballon to a specified marker\n//Add a listener to the marker to show the InfoText\n{Component.Object}.attachInfoText = function(marker, num) {\n  var infowindow = new google.maps.InfoWindow(\n      { content: {Component.Object}.InfoText[num]||\"\"\n      });\n\n  //This closure handles marker clicks\n  google.maps.event.addListener(marker, 'click', function() {\n    infowindow.open({Component.Object}.map,marker);\n  });\n} //end attachInfoText\n\n//Geocode the address in the address input box\n//If successful, make this the new map center, reinitialize\n// the markers, and add this as a new first marker\n{Component.Object}.encodeAddressField = function(){\n\t\n\tvar address = typeof arguments[0] != 'undefined' ? arguments[0] : document.getElementById(\"address\").value;\n\tvar ops = typeof arguments[1] != 'undefined' ? arguments[1] : {flagSetRadius: false, userCallbackFunctionName: ''};\n\tif(typeof address != 'string' || address == '') //mh 4/3/12\n\t\treturn;\n\n    {Component.Object}.geoCodeCallback({\n        'address': address\n    }, function(location){\n    \t\n        if ({Component.Object}.reinitOnGeocode) {\n        \t{Component.Object}.deleteOverlays();\n        \t{Component.Object}.map.setCenter(location);\n\t\t}\n        if({Component.Object}.markInitialPosition) {\n        \t\n\t\t\t{Component.Object}.titles.push(address);\n\t\t\t{Component.Object}.InfoText.push(location.toString());\n\t\t\t{Component.Object}.addMarker(location, {Component.Object}.isInitialDraggable);\n\t\t}\n\t\tif(ops.flagSetRadius) {Component.Object}.setMapSearchRadius();\n\t\tif(ops.userCallbackFunctionName != '') {\n\t\t\tif(typeof window[ops.userCallbackFunctionName] != 'undefined') {\n\t\t\t\twindow[ops.userCallbackFunctionName].call();\n\t\t\t}\n\t\t}\n    });\n} //end encodeAddressField\n\n//Hide bulk markers in a given layer\n{Component.Object}.hideLayer = function(layer){\n\tif ({Component.Object}.markersArray2) {\n\t    for (var i = 0 ; i <  {Component.Object}.markersArray2.length; i++) {\n\t    \tif ({Component.Object}.layersArray[i] == layer) {\n\t\t      {Component.Object}.markersArray2[i].setMap(null);\n\t\t      {Component.Object}.infoWindowsArray[i].close();\n\t\t      if({Component.Object}.circlesArray[i]){Component.Object}.circlesArray[i].setMap(null);\n\t\t      }\n\t    }\n\t}\n}\n\n//Show bulk markers in a given layer\n{Component.Object}.showLayer = function(layer){\n\tif ({Component.Object}.markersArray2) {\n\t    for (var i = 0 ; i <  {Component.Object}.markersArray2.length; i++) {\n\t    \tif ({Component.Object}.layersArray[i] == layer) {\n\t\t      {Component.Object}.markersArray2[i].setMap({Component.Object}.map);\n   \t\t      if({Component.Object}.circlesArray[i]){Component.Object}.circlesArray[i].setMap({Component.Object}.map);\n\t\t      }\n\t    }\n\t}\n}\n\n{Component.Object}.bounceLayer = function(layer, seconds,action){\n\tif ({Component.Object}.markersArray2) {\n\t    for (var i = 0; i <  {Component.Object}.markersArray2.length; i++) {\n\t    \tif ({Component.Object}.layersArray[i] == layer) {\n\t\t      {Component.Object}.bounceBulkMarker(parseInt(i) + 1, seconds,action);\n\t\t    }\n\t    }\n\t}\n}\n\n{Component.Object}.bounceBulkMarker = function(index, seconds,action){\n\t//mh 7/20/12 revision to handle rowNumber\n\tvar i = index - 1; //first guess, optimized for case of no missing markers\n\tvar actionN = 0\n\tif(action=='BOUNCE') actionN = 1;\n\tif(action=='DROP') actionN = 2;\n\tif ({Component.Object}.markersArray2.length > i && {Component.Object}.markersArray2[i].rowNumber == index) {\n\t\t{Component.Object}.markersArray2[i].setAnimation(actionN);\n\t\tsetTimeout('{Component.Object}.markersArray2['+i+'].setAnimation(null);',1000*seconds);\n\t\treturn;\n\t}\n\t//handle missing markers by brute-force searching for the right rowNumber, since number of rows is small\n\tfor (var i = 0 ; i < {Component.Object}.markersArray2.length; i++) {\n\t\tif ({Component.Object}.markersArray2[i].rowNumber == index) {\n\t\t\t{Component.Object}.markersArray2[i].setAnimation(actionN);\n\t\t\tsetTimeout('{Component.Object}.markersArray2['+i+'].setAnimation(null);',1000*seconds);\n\t\t\treturn;\n\t\t} //end if\n\t} //end for\n} //end bounceBulkMarker\n\n// Remove the markers from the map, but keep them in the array\n{Component.Object}.clearOverlays = function(){\n    if ({Component.Object}.markersArray) {\n        for (var i = 0; i <  {Component.Object}.markersArray.length; i++) {\n            {Component.Object}.markersArray[i].setMap(null);\n        }\n    }\n} //end clearOverlays\n\n// Show any markers currently in the array\n{Component.Object}.showOverlays = function(){\n    if ({Component.Object}.markersArray) {\n        for (var i = 0; i < {Component.Object}.markersArray.length; i++) {\n            {Component.Object}.markersArray[i].setMap({Component.Object}.map);\n        }\n    }\n} //end showOverlays\n\n//Turn marker displays on or off\n{Component.Object}.toggleMarkers = function(){\n    if ({Component.Object}.showMarkers) {\n        {Component.Object}.clearOverlays();\n        {Component.Object}.showMarkers = false;\n    }\n    else {\n        {Component.Object}.showOverlays();\n        {Component.Object}.showMarkers = true;\n    }\n} //end toggleMarkers\n\n{Component.Object}.deleteBulkMarkers = function() {\n\tif ({Component.Object}.markersArray2) {\n\t    for (var i = 0; i <{Component.Object}.markersArray2.length; i++) {\n\t      {Component.Object}.markersArray2[i].setMap(null);\n\t      if({Component.Object}.circlesArray[i]){Component.Object}.circlesArray[i].setMap(null);\n\n\t    }\n\t}\n    {Component.Object}.markersArray2.length = 0;\n\t{Component.Object}.infoWindowsArray.length = 0;\n\t{Component.Object}.layersArray.length = 0;\n\t{Component.Object}.circlesArray.length = 0;\n\tif ({Component.Object}.clusterBulkMarkers && {Component.Object}.clusterer != null)\n\t\t{Component.Object}.clusterer.clearMarkers();\n\n} //end deleteBulkMarkers\n\n// Delete all markers in the arrays by removing references to them\n{Component.Object}.deleteOverlays = function() {\n\tif ({Component.Object}.markersArray) {\n\t    \n\t    for (var i = 0; i < {Component.Object}.markersArray.length; i++) {\n\t      {Component.Object}.markersArray[i].setMap(null);\n\t    }\n\t}\n\t{Component.Object}.deleteBulkMarkers();\n\n    //zap the arrays for markers, titles, infotext, and layers\n    {Component.Object}.markersArray.length = 0;\n    {Component.Object}.titles.length = 0;\n    {Component.Object}.InfoText.length = 0;\n    //clear the Polygon and circle as well\n    {Component.Object}.clearPoly();\n    {Component.Object}.setRadius(0);\n\n} //end deleteOverlays\n\n//Create and show the polygon defined by the markers\n{Component.Object}.showPoly = function(){\n\tvar polyPath=[];\n\tif({Component.Object}.markersArray)\n\t\tfor (var i = 0; i < {Component.Object}.markersArray.length; i++)\n\t\t\tpolyPath.push({Component.Object}.markersArray[i].getPosition());\n    {Component.Object}.myPoly = new google.maps.Polygon({\n        paths: polyPath,\n        strokeColor: \"{PolygonColor}\",\n        strokeOpacity: 0.8,\n        strokeWeight: 2,\n        fillColor: \"{PolygonColor}\",\n        fillOpacity: 0.35,\n        clickable: false\n    });\n\n    {Component.Object}.myPoly.setMap({Component.Object}.map);\n} //end showPoly\n\n//Hide the polygon\n{Component.Object}.clearPoly = function(){\n\ttry {\n    \t{Component.Object}.myPoly.setMap(null);\n    } catch (e)\n    {\n    \t//ignore\n    }\n} //end clearPoly\n\n//Turn the polygon display on or off\n{Component.Object}.togglePoly = function(){\n    if ({Component.Object}.showPolygon) {\n        {Component.Object}.clearPoly();\n        {Component.Object}.showPolygon = false;\n    }\n    else {\n        {Component.Object}.showPoly();\n        {Component.Object}.showPolygon = true;\n    }\n} //end togglePoly\n\n//Show a circle on the map around the center point if wanted\n//Fit the map to the bounding box of the circle\n{Component.Object}.setRadius = function(value) {\n\ttry{ //hide any existing circle\n\t\t{Component.Object}.myCircle.setMap(null);\n\t} catch (e) {}\n\n\tif(!{Component.Object}.showCircle)\n\t\treturn;\n\n\t{Component.Object}.myRadius = parseInt(value);\n\n\tif({Component.Object}.markersArray && {Component.Object}.markersArray.length>=1 && {Component.Object}.myRadius>1) {\n\t\t{Component.Object}.myCircle = new google.maps.Circle({\n\t\t\tcenter: {Component.Object}.markersArray[0].getPosition(),\n\t\t\tradius: {Component.Object}.myRadius,\n\t        strokeColor: \"{CircleColor}\",\n\t        strokeOpacity: 0.8,\n\t        strokeWeight: 2,\n\t        fillColor: \"{CircleColor}\",\n\t        fillOpacity: 0.35,\n\t        clickable: false\n\t\t\t});\n\t\t{Component.Object}.myCircle.setMap({Component.Object}.map);\n\t\t{Component.Object}.map.fitBounds({Component.Object}.myCircle.getBounds());\n\t}\n} //end setRadius\n\n//Create a URL-encoded string contain the values to post back to the server\n{Component.Object}.computePostValues =function() {\n\tvar vals=\"\";\n\tvals += \"_npts=\"+{Component.Object}.markersArray.length;\n\tvals += \"&_radius=\"+{Component.Object}.myRadius;\n\tfor(var i = 0; i < {Component.Object}.markersArray.length; i++) {\n\t\tvals += \"&_LatLng\"+i+\"=\"+{Component.Object}.markersArray[i].getPosition();\n\t\t}\n\tvals += \"&_showCircle=\"+{Component.Object}.showCircle;\n\tvals += \"&_showMarkers=\"+{Component.Object}.showMarkers;\n\tvals += \"&_showPolygon=\"+{Component.Object}.showPolygon;\n\treturn vals;\n} //end computePostValues\n\n//Perform an Ajax callback to the Xbasic function 'TakeLatLng'\n// using computePostValues() to do the heavy lifting\n{Component.Object}.SubmitLatLng = function(){\n\t{Component.Object}.ajaxCallback('','','TakeLatLng','',{Component.Object}.computePostValues());\n} //end SubmitLatLng\n\n//Ajax callback to do Geocoding\n{Component.Object}.geoCodeCallback = function(arg, callback) {\nif(typeof arg.address != 'string' || arg.address == '') //mh 4/3/12\n\treturn;\n\nif ( {Component.Object}.GeocodeMethod=='Google' ) {\n\t//Google geocoder; should already have been initialized\n    {Component.Object}.geocoder.geocode(arg, function(results, status){\n        if (status == google.maps.GeocoderStatus.OK) {\n\t\t\tif (typeof callback == 'function')\n\t\t\t\tcallback(results[0].geometry.location);\n         }\n        else {\n        \tif (status != google.maps.GeocoderStatus.ZERO_RESULTS) //mh 4/3/12\n            \talert(\"{Component.Object}.geoCodeCallback using Google was not successful for the following reason: \" + status);\n        }\n    });\n  } // end if Google geocoding\nelse {\n\t//nominatim.openstreetmap.org\n\n\tvar url = \"http://nominatim.openstreetmap.org/search?format=json&q=\"+encodeURIComponent(arg.address);\n\tnew $a.simple(url, {\n\t\tmethod: 'get',\n\t\thandle: function(obj) {\n\t\t  if(obj.responseText) {\n\t\t\tvar ret=eval(obj.responseText);\n\t\t\tif(ret && ret[0] && ret[0].lat && ret[0].lon) {\n\t\t\t\tvar latlng = new google.maps.LatLng(ret[0].lat, ret[0].lon);\n\t\t\t\tif (typeof callback == 'function')\n\t\t\t\t\tcallback(latlng);\n\t\t\t}\n\t\t  }\n\t    }\n\t});\n  } //end else\n} // end {Component.Object}.geoCodeCallback\n\n\n%js%\n'e.tmpl.useSSL = .T.\n'Construct the correct Google Maps source - may have override from argument\n'if e.tmpl.useSSL\n\te.tmpl.GoogleMapsSrc = \"https://maps.googleapis.com/maps/api/js?\"\n'else\n'\te.tmpl.GoogleMapsSrc = \"http://maps.googleapis.com/maps/api/js?\"\n'end if\n\ne.tmpl.GoogleMapsSrc = e.tmpl.GoogleMapsSrc + \"callback=A5.googleMapsInit.init\"\n'e.tmpl.GoogleMapsSrc = e.tmpl.GoogleMapsSrc + \"&sensor=\" + TFtoJS(e.tmpl.useSensor)\n\nif e.tmpl.clientID <> \"\" .and. e.tmpl.usePremier\n'\te.tmpl.GoogleMapsSrc = e.tmpl.GoogleMapsSrc + \"&client=\" + alltrim(e.tmpl.clientID)\n\te.tmpl.GoogleMapsSrc = e.tmpl.GoogleMapsSrc + \"&key=\" + alltrim(e.tmpl.clientID)\n\te.tmpl.GeocodeMethod = \"Google\"\nend if\n\n\n\n'Replace parameters with their current argument values\ne.html = replace_placeholders_with_argument_values(e.html,e.arguments)\ne.javascript = replace_placeholders_with_argument_values(e.javascript,e.arguments)\n\n'Replace other parameters with their current property values\n'First do the HTML\nwp.SRString1 = <<%txt%\n{DivName}=e.tmpl.DivName\n{DivHeight}=e.tmpl.DivHeight\n{DivWidth}=e.tmpl.DivWidth\n{HtmlToolbar}=e.tmpl.HtmlToolbar\n%txt%\n\ne.html = stritran_multi_expressions(e.html,wp.SRString1)\n\n'And now the JavaScript..\n' but first fix up checkbox .T./.F. values to \"true\"/\"false\" for JavaScript\ndim markInitialPosition as C = TFtoJS(e.tmpl.markInitialPosition)\ndim showMarkers as C = TFtoJS(e.tmpl.showMarkers)\ndim showPolygon as C = TFtoJS(e.tmpl.showPolygon)\ndim showCircle as C = TFtoJS(e.tmpl.showCircle)\ndim isDraggable as C = TFtoJS(e.tmpl.isDraggable)\ndim isInitialDraggable as C = TFtoJS(e.tmpl.isInitialDraggable)\ndim reinitOnGeocode as C = TFtoJS(e.tmpl.reinitOnGeocode)\ndim useSensor as C = TFtoJS(e.tmpl.useSensor)\ndim initializeFromSensor as C = TFtoJS(e.tmpl.initializeFromSensor)\ndim setActiveRowOnMarkerClick as c = TFtoJS(e.tmpl.setActiveRowOnMarkerClick)\ndim clusterBulkMarkers as C = TFtoJS(e.tmpl.clusterBulkMarkers)\nwp.SRString2 = <<%txt%\n{DivName}=e.tmpl.DivName\n{showMarkers}=showMarkers\n{showPolygon}=showPolygon\n{PolygonColor}=e.tmpl.PolygonColor\n{markInitialPosition}=markInitialPosition\n{radius}=e.tmpl.radius\n{maxMarkers}=e.tmpl.maxMarkers\n{reinitOnGeocode}=reinitOnGeocode\n{showCircle}=showCircle\n{CircleColor}=e.tmpl.CircleColor\n{isDraggable}=isDraggable\n{isInitialDraggable}=isInitialDraggable\n{mapTypeId}=e.tmpl.mapTypeId\n{zoom}=e.tmpl.zoom\n{autoScaleToBulkMarkers}=e.tmpl.autoScaleToBulkMarkers\n{bulkMarkerClickAction}=e.tmpl.bulkMarkerClickAction\n{rightClickAction}=e.tmpl.rightClickAction\n{GeocodeDelay}=e.tmpl.GeocodeDelay\n{GeocodeMethod}=e.tmpl.GeocodeMethod\n{GoogleMapsSrc}=e.tmpl.GoogleMapsSrc\n{ParentGridAlias}=e.tmpl.gridComponentAlias\n{SetActiveRowOnMarkerClick}=setActiveRowOnMarkerClick\n{useSensor} = useSensor\n{initializeFromSensor} = initializeFromSensor\n{clusterBulkMarkers}=clusterBulkMarkers\n%txt%\n\ne.javascript = stritran_multi_expressions(e.javascript,wp.SRString2)\n\n\n'Convert markers from markerPropertyArray or markerPropertyArrayString\n'    Put them in an XBasic bulkMarkersArray for substitution into the JavaScript bulkMarkersArray\ndim bulkMarkersArray as C\nif e.tmpl.markerPropertyArrayString <> \"\"\n\tbulkMarkersArray = populateMarkersFromString(e.tmpl.markerPropertyArrayString)\nelse if e.tmpl.markerPropertyArray.size() > 0\n\tbulkMarkersArray = populateMarkersFromArray(e.tmpl.markerPropertyArray)\nend if\n\ne.javascript = stritran(e.javascript,\"{bulkMarkersArray}\",bulkMarkersArray)\n\n\nend function 'systemOnInitialRender\n\n",
            "systemOnComponentInitialize": "function systemOnComponentInitialize as v (e as p)\nend function 'systemOnComponentInitialize\n",
            "systemOnComponentExecute": "function systemOnComponentExecute as v (e as p)\nend function 'systemOnComponentExecute\n"
        },
        "activeLanguage": "<Default>",
        "fontScalingOption": "All",
        "mustRunInIFrame": false,
        "IframeInlineStyle": "width: 8in; height: 6in; border: none;",
        "masterTemplate": "",
        "saveFileType": "Formatted JSON",
        "info": {
            "dateLastEdited": "2018-2-25"
        },
        "pageTitle": "Component",
        "SVGLinkedFiles": "",
        "localsvg": "",
        "builder": {
            "workingPreviewEnabled": true,
            "previewEnabled": true
        },
        "selected": "",
        "designPaneIndex": 1,
        "masterPaneC": "TabbedUIProps",
        "serverSideEventIndex": 1,
        "clientSideEventIndex": 1,
        "clientSideEventIndexC": "1",
        "__WPhostName": "Internet Explorer",
        "embeddedMode": false,
        "_style_versionNumber": 4,
        "_style_hasSassOverrides": true,
        "_style_hasCSSTweaks": false,
        "_style_hassubthemeTweaks": false,
        "_style_hasCSS_or_subtheme_tweaks": false,
        "arguments": [
            {
                "Name": "CenterLat",
                "DataType": "Numeric",
                "Source": "RUNTIMEBINDING",
                "VariableScope": "",
                "VariableName": "",
                "DefaultValue": "0.0",
                "Data": 0
            },
            {
                "Name": "CenterLng",
                "DataType": "Numeric",
                "Source": "RUNTIMEBINDING",
                "VariableScope": "",
                "VariableName": "",
                "DefaultValue": "0.0",
                "Data": 0
            },
            {
                "Name": "CenterAddress",
                "DataType": "Character",
                "Source": "RUNTIMEBINDING",
                "VariableScope": "",
                "VariableName": "",
                "DefaultValue": ""
            },
            {
                "Name": "Titles",
                "DataType": "Character",
                "Source": "RUNTIMEBINDING",
                "VariableScope": "",
                "VariableName": "",
                "DefaultValue": ""
            },
            {
                "Name": "InfoText",
                "DataType": "Character",
                "Source": "RUNTIMEBINDING",
                "VariableScope": "",
                "VariableName": "",
                "DefaultValue": ""
            },
            {
                "Name": "DivName",
                "DataType": "Character",
                "Source": "RUNTIMEBINDING",
                "VariableScope": "",
                "VariableName": "",
                "DefaultValue": "map_canvas"
            }
        ],
        "systemXbasicFunctionDeclarations": "'TFtoJS: convert .T./.F. values from a checkbox to true/false for JavaScript\nfunction TFtoJS as c (TF as L )\n\tif TF then\n\t\tTFtoJS=\"true\"\n\telse\n\t\tTFtoJS=\"false\"\n\tend if\nend function\n\n'populateMarkersFromString: read Xbasic property array string and write a JavaScript array of objects\n'This function expects str to unpack to p.arr[n], with properties\n'    .type, .address, .lat, .lon, .title, .infotext, .layer, etc.\nFUNCTION populateMarkersFromString as C ( str as C)\n\tIF str = \"\" THEN\n\t\tpopulateMarkersFromString = \"\"\n\t\texit function\n\tEND IF\n\n\tdim p as p\n\tproperty_from_string(p,str)\n\n\tdim arr as p\n\tif eval_valid(\"p.arr\") = .f. then\n\t\texit function\n\tend if\n\tarr = p.arr\n\tpopulateMarkersFromString = populateMarkersFromArray(arr)\n\texit function\nEND FUNCTION\n\n'populateMarkersFromArray\nfunction populateMarkersFromArray as C (arr as P)\ndim i as n\ndim count as n\ndim js as c = \"\"\n\ncount = arr.size()\nif count = 0 then\n\texit function\nend if\nfor i = 1 to count\n\twith arr[i]\n\t\tdim showMarker as l = default .t.\n\t\tdim title as c = default \"\"\n\t\tdim infotext as c = default \"\"\n\t\tdim type as c = default \"\"\n\t\tdim icon as c = default \"\"\n\t\tdim layer as c = default \"\"\n\t\tdim animation as n = default 0\n\t\tdim duration as n = default 0\n\t\tdim callback as c = default \"\"\n\t\tdim lat as c = default \"\"\n\t\tdim lon as c = default \"\"\n\t\tdim circleObj as p\n\t\tdim circleObj.radius as n = default 0\n\t\tdim circleObj.strokeColor as c = default \"#00FF00\"\n\t\tdim circleObj.strokeOpacity as n = default .8\n\t\tdim circleObj.strokeWeight as n = default 2\n\t\tdim circleObj.fillColor as c = default \"#00FF00\"\n\t\tdim circleObj.fillOpacity as n = default .35\n\t\tdim isDraggable as l = default .F.\n\t\tdim dragFunction as c = default \"\"\n\tend with\n\tdelete pj\n\tdim pj as p\n\tif arr[i].type = \"address\" then\n\t\tpj.type = \"address\"\n\t\tpj.address = arr[i].address\n\telse\n\t\tpj.type = \"coord\"\n\t\tpj.lat = arr[i].lat\n\t\tpj.lon = arr[i].lon\n\tend if\n\tpj.title = arr[i].title\n\tpj.infotext = arr[i].infotext\n\tif arr[i].icon <> \"\" then\n\t\tpj.icon = arr[i].icon\n\tend if\n\tif arr[i].layer <> \"\" then\n\t\tpj.layer = arr[i].layer\n\tend if\n\tif arr[i].animation <> 0 then\n\t\tpj.animation = arr[i].animation\n\tend if\n\tif arr[i].duration <> 0 then\n\t\tpj.duration = arr[i].duration\n\tend if\n\tif arr[i].callback <> \"\" then\n\t\tpj.callback = arr[i].callback\n\tend if\n\tif arr[i].circleObj <> \"\" then\n\t\tpj.circleObj = arr[i].circleObj\n\tend if\n\tpj.isDraggable = arr[i].isDraggable\n\tif arr[i].dragFunction <> \"\" then\n\t\tpj.dragFunction = arr[i].dragFunction\n\tend if\n\t\n\tpj.realRowNum = i \n\t'selwyn - do not add a marker if showMarker is set to .f. - we now expose a property to hide marker if lat/lng is 0 in the alt view builder\n\tif arr[i].showMarker = .t. then\n\t\tjs = js + vartojson(pj,.f.,.t.)\t + crlf()\n\tend if \nnext i\njs = crlf_to_comma(js)\npopulateMarkersFromArray = js\nend function\n\n\n",
        "componentType": "CustomComponent",
        "version": 1,
        "toolBox_value": "",
        "addinBuildNumber": "5044",
        "addinBuildNumberHighestUsed": "5044",
        "alphaFiveBuildNumber": "12",
        "openedFromTemplate": false,
        "builderVersionNumber": 1,
        "builtWithVersionNumer": 1,
        "_buildCount": "2",
        "securityEnabled": false,
        "showHideIsUsed": false,
        "A5SaveTimeStamp": "20180225121356605"
    }
}